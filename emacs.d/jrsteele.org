#+Title: Jonathan Steele's Emacs Configuration
#+OPTIONS: toc:4 h:4
* Introduction
#+BEGIN_QUOTE
Blah blah blah, something about literate programming.

--Me
#+END_QUOTE
Initially I was pretty fond of using the configuration provided by the
[[http://spacemacs.org][Spacemacs]] project, but after some time found
it to be a bit too cumberso
me and
also proved to be quite slow when loading =Emacs= initially. After much
deliberation, I decided it was time to winnow my configuration down to only the
bits that I had used on a more frequent basis.

At first, I started utilizing a series of configuration files in my ~.emacs.d~
directory that were broken out by category and purpose. After several hours of
tweaking and perfecting, that too still felt a bit thrown together with no real
documentation either. I mentioned to a coworker--and fellow Emacs user--that I
was refactoring my configuration files, and he mentioned the ability to store
everything within ~Org~ mode files.

After doing some initial research, I was immediately hooked and began moving all
of my customizations into the sections listed below.
* Settings
** Bootstrapping Emacs
In order for Emacs to properly load this file, your =~/.emacs.d/init.el= file
should look like the following:
#+BEGIN_EXAMPLE
  ;;; init.el --- Where all the magic begins
  ;;
  ;; This file allows Emacs to initialize my customizations
  ;; in Emacs lisp embedded in *one* literate Org-mode file.

  ;; This sets up the load path so that we can override it

  ;; Added by Package.el.  This must come before configurations of
  ;; installed packages.  Don't delete this line.  If you don't want it,
  ;; just comment it out by adding a semicolon to the start of the line.
  ;; You may delete these explanatory comments.

  (package-initialize)
  (setq package-enable-at-startup nil)

  (require 'org)
  (org-babel-load-file (expand-file-name "jrsteele.org" "~/.emacs.d"))

  ;; Keep emacs Custom-settings in separate file
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
  ;;; init.el ends here
#+END_EXAMPLE
** Speed up loading of emacs
Avoid garbage collection during startup. The GC eats up quite a bit of
time, easily doubling startup time. The trick is to turn up the memory
threshold to prevent it from running:
#+BEGIN_SRC emacs-lisp
  ;; (setq gc-cons-threshold 402653184
  ;;       gc-cons-percentage 0.6)
#+END_SRC

Like we did with the garbage collector, unset file-name-handler-alist
too (temporarily). Every file opened and loaded by Emacs will run
through this list to check for a proper handler for the file, but
during startup, it won’t need any of them
#+BEGIN_SRC emacs-lisp
  ;; (defvar temp--file-name-handler-alist file-name-handler-alist)
  ;; (setq file-name-handler-alist nil)
#+END_SRC
** My information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Jonathan R. Steele"
        user-mail-address "jrsteele@gmail.com")
#+END_SRC
** Package Support
I utilize the use-package macro for handling all of my package needs.
#+BEGIN_SRC emacs-lisp
  (require 'package)

  (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                           ("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "https://melpa.org/packages/")))
  (package-initialize)
  (setq load-prefer-newer t)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (use-package diminish :ensure t)
#+END_SRC
** Generic Emacs Customizations
*** Emacs Server
Enable the Emacs server at startup
#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC

Also set the =EDITOR= environment variable to be =emacsclient=
#+BEGIN_SRC emacs-lisp
  (setenv "EDITOR" "emacsclient")
#+END_SRC
*** Disable Auto save
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil)
#+END_SRC
*** Disable Backup Files
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC
*** No tabs
Ensure that when I hit =tab= that it will provide 4 spaces rather than the
tab character.
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 4)
#+END_SRC
*** Switch Prompts
Change yes or no prompts into y or n
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Remove trailing whitespaces
This annoys the crap out of me.
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
*** Which Key
Shows which keys can be pressed next. Eg. if you press C-x and wait a
few seconds, a window pops up with all the key bindings following the
currently entered incomplete command.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config  (which-key-mode))
#+END_SRC
*** Enable Global Undo Tree Mode
I used to hate this mode with a passion, but after having it enabled
for sometime, I now can't live without it.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    (global-undo-tree-mode))
#+END_SRC
*** Utility functions
#+BEGIN_SRC emacs-lisp
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    "Supply a FILENAME, to hide a minor MODE or replace with an ABBREV."
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    "Supply a MODE-HOOK, to hide a major MODE or replace with an ABBREV."
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))
#+END_SRC
** Interface
I generally like to hide the scroollbar and menubar in both the
graphical and terminal based mode of =Emacs=.
*** Diminish some modes
Hide or diminish some major and minor modes within Emacs
#+BEGIN_SRC emacs-lisp
  ;; (diminish-minor-mode 'auto-complete 'auto-complete-mode " ⓐ ")
  ;; (diminish-minor-mode 'flycheck 'flycheck-mode " ⓕ ")
  ;; (diminish-minor-mode 'projectile 'projectile-mode " ⓟ ")
  ;; (diminish-minor-mode 'robe 'robe-mode " ⓡ ")
  ;; (diminish-minor-mode 'flymake 'flymake-mode " ⓜ ")
  ;; (diminish-minor-mode 'server 'server-mode)
  ;; (diminish-minor-mode 'evil-snipe 'evil-snipe-local-mode)
  ;; (diminish-minor-mode 'evil-surround 'evil-surround-mode )
  ;; (diminish-minor-mode 'evil-commentary 'evil-commentary-mode)
  ;; (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  ;; (diminish-minor-mode 'autorevert 'auto-revert-mode)
  ;; (diminish-minor-mode 'flyspell 'flyspell-mode)
  ;; (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  ;; (diminish-minor-mode 'evil-org 'evil-org-mode)
  ;; (diminish-minor-mode 'git-gutter 'git-gutter-mode)
  ;; (diminish-minor-mode 'company 'company-mode)
  ;; (diminish-minor-mode 'doom-buffer 'doom-buffer-mode)
  ;; (diminish-minor-mode 'rainbow 'rainbow-mode)

  ;; (diminish-major-mode 'emacs-lisp-mode-hook ".el")
  ;; (diminish-major-mode 'haskell-mode-hook "?=")
  ;; (diminish-major-mode 'lisp-interaction-mode-hook "?")
  ;; (diminish-major-mode 'python-mode-hook ".py")
  ;; (diminish-major-mode 'ruby-mode-hook ".rb")
  ;; (diminish-major-mode 'sh-mode-hook ".sh")
  ;; (diminish-major-mode 'markdown-mode-hook ".md")
  ;; (diminish-major-mode 'web-mode ".html")
#+END_SRC
*** OSX Specific settings
**** Disable the menubar mode
#+BEGIN_SRC emacs-lisp
  (unless (eq window-system 'mac)
    (when (and (fboundp 'menu-bar-mode) (not (eq menu-bar-mode -1)))
      (menu-bar-mode -1)))
#+END_SRC
**** Set font and ligatures
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (progn (set-frame-font "Ligalex Mono Medium 11" t t) (mac-auto-operator-composition-mode 1)))
#+END_SRC
*** Enable column number mode
I tend to prefer to see what column my text/cursor is located at so I can
better adhere to the 80 column rule.
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC
*** Disable the scrollbar
#+BEGIN_SRC emacs-lisp
  (when (and (fboundp 'scroll-bar-mode) (not (eq scroll-bar-mode -1)))
    (scroll-bar-mode -1))
#+END_SRC
*** Disable the toolbar
#+BEGIN_SRC emacs-lisp
  (when (and (fboundp 'tool-bar-mode) (not (eq tool-bar-mode -1)))
    (tool-bar-mode -1))
#+END_SRC
*** Theme
This area tends to be in a lot of flux, and right now I've been a fan
of the =aproproriate= theme.
#+BEGIN_SRC emacs-lisp
  (use-package apropospriate-theme
    :ensure t
    :config
    (load-theme 'apropospriate-dark t))

    ;; (let ((line (face-attribute 'mode-line :underline)))
    ;;   (set-face-attribute 'mode-line          nil :overline   line)
    ;;   (set-face-attribute 'mode-line-inactive nil :overline   line)
    ;;   (set-face-attribute 'mode-line-inactive nil :underline  line)
    ;;   (set-face-attribute 'mode-line          nil :box        nil)
    ;;   (set-face-attribute 'mode-line-inactive nil :box        nil)))


  (use-package seoul256-theme
    :ensure t
    :disabled t
    :config
    (setq seoul256-background 237)
    (load-theme 'seoul256 t))

  (use-package material-theme
    :ensure t
    :disabled t
    :config (load-theme 'material t))

  (use-package nord-theme
    :ensure t
    :disabled t
    :config (load-theme 'nord t))

  (use-package poet-theme
    :ensure t
    :disabled t
    :config
    (progn
      (set-face-attribute 'default nil :family "Fira Code" :height 130)
      (set-face-attribute 'fixed-pitch nil :family "Fira Code")
      (set-face-attribute 'variable-pitch nil :family "Fira Sans")
      (add-hook 'text-mode-hook
                (lambda ()
                  (variable-pitch-mode 1)))))
#+END_SRC

*** Mode Line modifications
While I was doing research on a powerline like funcationality
for emacs, I discovered this package that will beautifully
reduce the amount of "clutter" found in the typical emacs
mode line.
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :ensure t
    :defer t

    :hook (after-init . doom-modeline-init)
    :config
    (setq doom-modeline-height 25)
  )
#+END_SRC

Moody mode line, from the creator of =Magit=.
#+BEGIN_SRC emacs-lisp
  (use-package moody
    :ensure t
    :disabled t
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))

  (use-package minions
    :ensure t
    :disabled t
    :config (minions-mode 1))



#+END_SRC

And Back to spaceline until doom-modeline gets its shit together
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :disabled t
    :config
    (setq powerline-height 29)
    (setq powerline-default-separator 'utf-8)
    ;(setq spaceline-separator-dir-left '(right . right))
    ;(setq spaceline-separator-dir-right '(right . right))
    ;(setq powerline-default-separator 'alternate) ;; alternate, slant, wave, zigzag, nil.
    (setq spaceline-workspace-numbers-unicode t) ;for eyebrowse. nice looking unicode numbers for tagging different layouts
    (setq spaceline-window-numbers-unicode t)
    ;(setq spaceline-highlight-face-func #'spaceline-highlight-face-evil-state) ; set colouring for different evil-states
    (require 'spaceline-config)
    ;; (spaceline-spacemacs-theme)
    ;; (spaceline-emacs-theme)
    (spaceline-compile)
    (spaceline-toggle-minor-modes-off))


  (use-package spaceline-all-the-icons
    :after spaceline
    :ensure t
    :disabled t
    :config
    (setq spaceline-all-the-icons-separator-type (quote none))
    (setq spaceline-all-the-icons-icon-set-flycheck-slim (quote dots))
    (setq spaceline-all-the-icons-icon-set-window-numbering 'solid)
    (setq spaceline-all-the-icons-flycheck-alternate t)
    (setq spaceline-all-the-icons-hide-long-buffer-path t)
    (setq powerline-text-scale-factor 1.3)
    (spaceline-all-the-icons-theme)
    (spaceline-all-the-icons--setup-neotree)
    (spaceline-toggle-all-the-icons-flycheck-status-on)
    (spaceline-toggle-all-the-icons-vc-icon-off)
    (spaceline-toggle-all-the-icons-git-status-off)
    (spaceline-toggle-all-the-icons-mode-icon-on)
    (spaceline-toggle-all-the-icons-region-info-on))
#+END_SRC

Rich Minority Mode further diminishes mode lines by utilizing a white
or blacklist to show or hide any minor modes
#+BEGIN_SRC emacs-lisp
  (use-package rich-minority
    :ensure t
    :config
    (setq rm-whitelist '("flycheck"))
    (rich-minority-mode 1))
#+END_SRC

*** Golden Ratio Windows
Automatically resize windows using the golden ratio when activating a
pane.
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :ensure t
    :diminish golden-ratio-mode
    :disabled t
    :init
    (golden-ratio-mode 1)
    :config
    (setq golden-ratio-extra-commands
          (append golden-ratio-extra-commands
                  '(winum-select-window-0
                    winum-select-window-1
                    winum-select-window-2
                    winum-select-window-3
                    winum-select-window-4
                    winum-select-window-5
                    winum-select-window-6
                    winum-select-window-7
                    winum-select-window-8
                    winum-select-window-9))))
#+END_SRC
*** Auto Dim other buffers
Dim non-active buffers to improve focus.
#+BEGIN_SRC emacs-lisp
  (use-package auto-dim-other-buffers
    :ensure t
    :diminish Dim
    :disabled t
    :init
    (progn
      (add-hook 'after-init-hook (lambda ()
                                   (when (fboundp 'auto-dim-other-buffers-mode)
                                     (auto-dim-other-buffers-mode t))))))
#+END_SRC

*** Update the titlebar
Emacs@hostname is not very useful information for the title bar, so I
have it display the current buffer file path instead.
#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '("" invocation-name ": "(:eval (if (buffer-file-name)
                                        (abbreviate-file-name (buffer-file-name))
                                      "%b"))))
#+END_SRC

*** Terminal updates
Apply some color fixes to both eterm and ansi-term to make these
terminals more useful.
#+BEGIN_SRC emacs-lisp
  (use-package xterm-color
    :ensure t)

  (use-package eterm-256color
    :ensure t
    :config
    (add-hook 'term-mode-hook #'eterm-256color-mode))

#+END_SRC

*** Eshell Customizations
Let's try to make eshell look nicer than what it is.
#+BEGIN_SRC emacs-lisp
  (require 'dash)
  (require 's)

  (defmacro with-face (STR &rest PROPS)
    "Return STR propertized with PROPS."
    `(propertize ,STR 'face (list ,@PROPS)))

  (defmacro esh-section (NAME ICON FORM &rest PROPS)
    "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
    `(setq ,NAME
           (lambda () (when ,FORM
                   (-> ,ICON
                      (concat esh-section-delim ,FORM)
                      (with-face ,@PROPS))))))

  (defun esh-acc (acc x)
    "Accumulator for evaluating and concatenating esh-sections."
    (--if-let (funcall x)
        (if (s-blank? acc)
            it
          (concat acc esh-sep it))
      acc))

  (defun esh-prompt-func ()
    "Build `eshell-prompt-function'"
    (concat esh-header
            (-reduce-from 'esh-acc "" eshell-funcs)
            "\n"
            eshell-prompt-string))

  (esh-section esh-dir
               "\xf07c"  ;  (faicon folder)
               (abbreviate-file-name (eshell/pwd))
               '(:foreground "cornflower blue" :bold ultra-bold :underline f))

  (esh-section esh-git
               "\xe907"  ;  (git icon)
               (ignore-errors
                 (magit-get-current-branch))
               '(:foreground "pink"))

  (esh-section esh-python
               "\xe928"  ;  (python icon)
               pyvenv-virtual-env-name)

  (esh-section esh-clock
               "\xf017"  ;  (clock icon)
               (format-time-string "%H:%M" (current-time))
               '(:foreground "forest green"))

  (esh-section esh-kubectx
               "\x2388" ; ⎈ (helm symbol)
               (replace-regexp-in-string "\n$" ""
                                         (shell-command-to-string "kubectl config current-context"))
               '(:foreground "tomato"))

  ;; Below I implement a "prompt number" section
  (setq esh-prompt-num 0)
  (add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
  (advice-add 'eshell-send-input :before
              (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

  (esh-section esh-num
               "\xf0c9"  ;  (list icon)
               (number-to-string esh-prompt-num)
               '(:foreground "brown"))

  ;; Separator between esh-sections
  (setq esh-sep " | ")  ; or " | "

  ;; Separator between an esh-section icon and form
  (setq esh-section-delim " ")

  ;; Eshell prompt header
  (setq esh-header "\n┌─")  ; or "\n┌─"

  ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
  ;; your login, these can be the same.
  (setq eshell-prompt-regexp "└─> ")   ; or "└─> "
  (setq eshell-prompt-string "└─> ")   ; or "└─> "

  ;; Choose which eshell-funcs to enable
  (setq eshell-funcs (list esh-dir esh-git esh-kubectx))

  ;; Enable the new eshell prompt
  (setq eshell-prompt-function 'esh-prompt-func)

#+END_SRC
** Navigation
*** Window Numbering
I like to use the window-numbering package to easily bounce between windows
by using =M-<number>=
#+BEGIN_SRC emacs-lisp
  (use-package winum
    :ensure t
    :init
    (setq winum-keymap
          (let ((map (make-sparse-keymap)))
            (bind-key (kbd "M-0") #'winum-select-window-0-or-10 map)
            (bind-key (kbd "M-1") #'winum-select-window-1 map)
            (bind-key (kbd "M-2") #'winum-select-window-2 map)
            (bind-key (kbd "M-3") #'winum-select-window-3 map)
            (bind-key (kbd "M-4") #'winum-select-window-4 map)
            (bind-key (kbd "M-5") #'winum-select-window-5 map)
            (bind-key (kbd "M-6") #'winum-select-window-6 map)
            (bind-key (kbd "M-7") #'winum-select-window-7 map)
            (bind-key (kbd "M-8") #'winum-select-window-8 map)
            (bind-key (kbd "M-9") #'winum-select-window-9 map)
            map)
          winum-auto-setup-mode-line nil)
    :config
    (winum-mode))
#+END_SRC
*** Better searching
I'm using swiper and ivy to serch buffers
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :diminish ivy-mode
    :init
    (setq ivy-display-style 'fancy
          ivy-height 4
          ivy-use-virtual-buffers t)
    (ivy-mode 1)
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           ("C-c C-r" . ivy-resume)))
#+END_SRC
*** Project Browsing
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-mode-line
          '(:eval (format " [%s]" (projectile-project-name))))
    (setq projectile-remember-window-configs t)
    (setq projectile-completion-system 'ivy)
    (setq projectile-switch-project-action 'projectile-dired))

#+END_SRC
*** Better M-x
Use counsel to provide better M-x functionality
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :init
    (global-unset-key (kbd "C-z"))
    :bind
    ("M-x" . counsel-M-x)
    ("C-z f" . counsel-describe-function)
    ("C-z v" . counsel-describe-variable)
    ("C-c k" . counsel-ag))
#+END_SRC
*** NeoTree
This package mimics =Vim='s =NERDTree= plugin that provides a file
browser.
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :config
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))
#+END_SRC
*** Imenu List
Display a list of imenu items off to the side of the screen.
#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :ensure t
    )
#+END_SRC
** Text settings
*** Spellchecking
I'd like to think of myself as a person who spells things relatively well, but
this will provide me with some extra insurance
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :diminish flyspell
    :ensure t
    :bind (("C-`" . ispell-word)
           ("C-~" . ispell-buffer))
    :init
    (dolist (hook '(text-mode-hook org-mode-hook))
      (add-hook hook (lambda () (flyspell-mode 1)))))
#+END_SRC
*** 80 Column Word-wrapping
#+BEGIN_SRC emacs-lisp
  (setq fill-column 80)
  (dolist (hook '(text-mode-hook org-mode-hook))
    (add-hook hook (lambda () (auto-fill-mode 1))))
#+END_SRC
*** Org mode
**** Org babel source blocks
Enable syntax highlighting within the source blocks and keep the editing pop-up
 window within the same window. Also, strip leading and trailing empty lines if
any.
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively                       t
        org-src-window-setup                           'current-window
        org-src-strip-leading-and-trailing-blank-lines t
        org-src-tab-acts-natively                      t)
#+END_SRC
**** Org cleanup
I like to utilize the appropriate indentation and hide the leading
stars when browsing around in Org mode. I also like using a special
character to denote note expansion.
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t
        org-odd-level-only nil
        org-ellipsis " ▼" )
#+END_SRC
**** Enable export to =Markdown= files
#+BEGIN_SRC emacs-lisp
  (eval-after-load "org"
    '(require 'ox-md nil t))
#+END_SRC
**** Set my Org-mode agenda files
Load default agenda files for tracking my ever-growing lists of
tasks. Also, set =CTRL+C-a= as my org-agenda binding
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list "~/Work/notes.org"))
  (define-key global-map "\C-ca" 'org-agenda)
#+END_SRC
**** Org Babel support
Add supported languages for Org Mode to execute.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sql . t)
     (python .t)))
#+END_SRC
*** LaTeX Mode
Enable the ever so powerful AUCTeX package for some added features
when in latex mode
#+BEGIN_SRC emacs-lisp
  (use-package auctex
    :ensure t
    :mode ("\\.tex\\'" . latex-mode)
    :commands (latex-mode LaTeX-mode plain-tex-mode)
    :init
    (progn
      (add-hook 'LaTeX-mode-hook #'LaTeX-preview-setup)
      (add-hook 'LaTeX-mode-hook #'flyspell-mode)
      (setq TeX-auto-save t
        TeX-parse-self t
        TeX-save-query nil
        TeX-PDF-mode t
        shell-escape-mode "-shell-escape"
        latex-run-command "xelatex")
      (setq-default TeX-master nil)))
#+END_SRC
Also enable preview mode for in-line previews
#+BEGIN_SRC emacs-lisp
  (use-package preview
    :commands LaTeX-preview-setup
    :init
    (progn
      (setq-default preview-scale 1.4
                    preview-scale-function '(lambda ()
                                              (* (/ 10.0 (preview-document-pt))
                                                 preview-scale)))))
#+END_SRC
*** PDF Tools
The PDF tools package implements a nicer looking pdf preview when
viewing these files from within Emacs. It also supports auto synching
between the source LaTeX file and the PDF.
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config
    (pdf-tools-install))
#+END_SRC
*** Dot Mode
Use this simple package for highlighitng graphviz dot files
#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :ensure t)
#+END_SRC
** Development Related Settings
*** Git Integration
**** Integrate magit
I typicaly utilize the default bindings with magit.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    (("C-c m s" . magit-status)
     ("C-c m b" . magit-blame))
    :config
    (setq magit-completing-read-function 'ivy-completing-read))
#+END_SRC
**** Git Gutter
Display new additions, modifications, or deletions within the gutter.
I prefer to see these changes on the right hand side of the screen.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe
    :ensure t
    :diminish git-gutter-mode
    :config
    (use-package git-gutter
      :ensure t)
    (setq git-gutter-fr:side 'right-fringe)
    (global-git-gutter-mode +1))
#+END_SRC
*** LSP Mode
This mode integrates the language server protocol into Emacs for
better code completion and debugging
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :config
    (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
    (setq lsp-auto-guess-root t)
    (add-hook 'python-mode-hook #'lsp))


  (use-package lsp-ui
    :ensure t
    :config
    (setq lsp-ui-sideline-ignore-duplicate t)
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))

  (use-package company-lsp
    :ensure t
    :config
    (push 'company-lsp company-backends))

  ;; (use-package lsp-python
  ;;   :ensure t
  ;;   :config
  ;;   (add-hook 'python-mode-hook (lambda () (lsp-python-enable))))
#+END_SRC
*** Auto completion
Utilize Company mode for autocompletion
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :diminish company-mode
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    :bind
    ("M-/" . company-complete-common)
    :config
    (setq company-dabbrev-downcase nil))
#+END_SRC
*** Syntax / Error Checking
Install and use flyckeck for determining code issues
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :diminish flycheck
    :config
    (setq flycheck-check-syntax-automatically '(mode-enabled save idle-change))
    (add-hook 'sh-mode-hook 'flycheck-mode))
#+END_SRC
*** Smartparens
This package makes dealing with parentheses, braces, and
brackest much easisr. For now I use the default settings
and enable it globally
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (smartparens-global-mode 1))

#+END_SRC
*** Rainbow Parentheses
This helpful little package will highlight matching parentheses so it makes
determining if the parentheses do infact match.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (dolist (hook '(python-mode-hook emacs-lisp-mode-hook))
      (add-hook hook #'rainbow-delimiters-mode)))
#+END_SRC
*** Python Development
**** Anaconda Mode
Add additional code navigation support for python-mode via anaconda-mode.
This provides better eldoc, jump to definitions.
#+BEGIN_SRC emacs-lisp
    (use-package anaconda-mode
      :ensure t
      :diminish anaconda-mode
      :config
      (add-hook 'python-mode-hook 'anaconda-mode)
      (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC
***** Anaconda Company Mode
Use Anaconda's company mode backend for code completion.
#+BEGIN_SRC emacs-lisp
  (use-package company-anaconda
    :ensure t
    :config
    (eval-after-load "company"
      '(add-to-list 'company-backends 'company-anaconda))
    (add-hook 'python-mode-hook 'anaconda-mode))
#+END_SRC
**** Python Mode
I prefer to utilize the default python mode package that comes with emacs, but
I like using ipython rather than the standard python interpreter
#+BEGIN_SRC emacs-lisp
  (use-package python
    :ensure t
    :diminish python-mode
    :config
    (defun my/python-mode-hook ()
      (setq flycheck-flake8-maximum-complexity 10))
     (setq python-shell-interpreter "ipython"
            python-shell-interpreter-args "--simple-prompt -i")
      (add-hook 'python-mode-hook 'flycheck-mode)
      (add-hook 'python-mode-hook 'my/python-mode-hook)
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("ipython" . python-mode))
#+END_SRC

**** Custom pytest method
For any new project, I've been using =py.test= to load and execute
tests. This will create a =comint= buffer which will execute =py.test=
and if need be, step through code in the buffer.
#+BEGIN_SRC emacs-lisp
  (defun pytest ()
    n"Run pytest"
    (interactive)
    (let ((python-shell-interpreter-args (concat (executable-find "pytest")
                                                 " -- -s")))
      (python-shell-make-comint (python-shell-parse-command) "pytest")))

  (defun pytest-current-buffer ()
    "Run tests from the current buffer"
    (interactive)
    (let ((python-shell-interpreter-args
           (concat (executable-find "pytest")
                   " -- -s -x --cov="
                   (replace-regexp-in-string "tests/" "" default-directory)
                   " --cov-report=term-missing "
                   (buffer-file-name))))
      (python-shell-make-comint (python-shell-parse-command) "pytest" )))

  (defun my/python-unit-test-keys ()
    (local-set-key (kbd "C-x t b") 'pytest-current-buffer)
    (local-set-key (kbd "C-x t t") 'pytest))

  (add-hook 'python-mode-hook 'my/python-unit-test-keys)

  ;; (when (eq (major-mode) 'python-mode)
  ;;   (progn
  ;;     (bind-key (kbd "C-x t b") 'pytest-current-buffer)
  ;;     (bind-key (kbd "C-x t t") 'pytest)))
#+END_SRC

**** Virtual Environment Support
#+BEGIN_SRC emacs-lisp
  (use-package pyvenv
    :ensure t
    :diminish pyvenv
    :bind
    ("M-RET v" . pyvenv-workon)
    :config
     (defun pyenv-venv-wrapper-act (&optional ARG PRED)
       (setenv "VIRTUAL_ENV"
               (shell-command-to-string "_pyenv_virtualenv_hook; echo -n $VIRTUAL_ENV")))
     (advice-add 'pyenv-mode-set :after 'pyenv-venv-wrapper-act)
     (defun pyenv-venv-wrapper-deact (&optional ARG PRED)
       (setenv "VIRTUAL_ENV"))
     (advice-add 'pyenv-mode-unset :after 'pyenv-venv-wrapper-deact))
#+END_SRC
**** Django Support
I utilize =pony-mode= to allow me to run Django's management
commands from Emacs. It also supports virtual environments and
the following can be added to a ~.dir-locals.el~ file:
#+NAME: Local Pony Configuration Example
#+BEGIN_EXAMPLE emacs-lisp
  ((nil .
        ((pony-settings (make-pony-project
                         :python (concat (getenv "VIRTUAL_ENV") "/bin/python")
                         :pythonpath "~/project/src"
                         :settings "web.local_settings")))))
#+END_EXAMPLE
#+BEGIN_SRC emacs-lisp
  (use-package pony-mode
    :ensure t
    :diminish pony-minor-mode)
#+END_SRC
*** Indent indicators
Developing in Python full time oftentimes requires the use of this
little aid to ensure my indents are lined up appropriately.
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :ensure t
    :config
    (setq highlight-indent-guides-method 'character)
    :init
    (progn
      (add-hook 'python-mode-hook 'highlight-indent-guides-mode)
      (add-hook 'yaml-mode-hook 'highlight-indent-guides-mode)
      (add-hook 'lua-mode-hook 'highlight-indent-guides-mode)))
#+END_SRC
*** Web Mode
This major mode offers better support for HTML, JavaScript, and Django
templates.
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :diminish web-mode
    :mode (("\\.html?\\'" . web-mode))
    :config
    (setq web-mode-engines-alist
          '(("django" . "\\.html\\'")))
    :init
    (setq web-mode-markup-indent-offset 4
          web-mode-code-indent-offset 4
          web-mode-style-padding 4
          web-mode-script-padding 4
          web-mode-block-padding 4))
#+END_SRC
*** Scala Development
=ENSIME= seems to the goto package for Scala development.
#+BEGIN_SRC emacs-lisp
  (use-package ensime
    :ensure t
    :config
    (setq ensime-startup-snapshot-notification nil))
#+END_SRC
*** C development
Irony mode is a minor mode for C/C++/ObjC development. It adds some
better autocompletion.
#+BEGIN_SRC emacs-lisp
  (use-package irony
    :ensure t
    :diminish irony-mode
    :config
    (add-hook 'c-mode-hook 'irony-mode))
#+END_SRC
Setup auto-completion for C libraries. This includes =company-c-headers=
and =company-irony=
#+BEGIN_SRC emacs-lisp
  (use-package company-irony
    :ensure t
    :config
    (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
    (eval-after-load 'company
      '(add-to-list 'company-backends 'company-irony)))

  (use-package company-c-headers
    :ensure t
    :config
    (add-to-list
     'company-c-headers-path-user
     "/Applications/Postgres.app/Contents/Versions/latest/include/postgresql/server")
    (eval-after-load "company"
      '(add-to-list 'company-backends 'company-c-headers))
    (add-hook 'c-mode-hook 'company-mode))
#+END_SRC

Enable Language Server Protocol for C development
#+BEGin_SRC emacs-lisp
  (defun cquery//enable ()
    (lsp)
    (flycheck-mode))

  (use-package cquery
    :ensure t
    :config
    (require 'cquery)
    (setq cquery-executable "/usr/local/bin/cquery")
    (setq cquery-extra-init-params '(:extraClangArguments ("-I/Applications/Postgres.app/Contents/Versions/latest/include/postgresql/server")))
    (add-hook 'c-mode-hook #'cquery//enable)
    (add-hook 'c++-mode-hook #'cquery//enable))

#+END_SRC
*** Dockerfile support
Add syntax and image building support straight from Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :diminish dockerfile-mode
    :config
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))
#+END_SRC
*** Markdown support
A lot of our repositories' documentation will be written in =Markdown=
format, so this package helps me write, and preview =Markdown=
documents.
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC
*** YAML support
Provide support for Yet Another Markup Language
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t)
#+END_SRC
*** Remote Host access through ansi-term
This will enable me to remotely access other hosts directly through
Emacs rather than launching either =ansi-term= or =eshell= mode.
#+BEGIN_SRC emacs-lisp
  (defun remote-term (new-buffer-name cmd &rest switches)
    (setq term-ansi-buffer-name (concat "*" new-buffer-name "*"))
    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
    (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name cmd nil switches))
    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-char-mode)
    (term-set-escape-char ?\C-x)
    (switch-to-buffer term-ansi-buffer-name))
#+END_SRC
*** Multi-Term Mode
Handle multiple terminals within Emacs. Hopefully this will allow me
to not have to leave Emacs for doing other development related tasks.
#+BEGIN_SRC emacs-lisp
  (use-package multi-term
    :ensure t
    :bind (
           ("C-c n" . multi-term-next)
           ("C-c t" . multi-term)))
#+END_SRC
*** C# Development Mode

That's right, after 4 years (at the time of writing), I've started to
dabble in C# related technologies again.

#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :ensure t
    :diminish csharp-mode
    :config
    (electric-pair-local-mode 1))

  (use-package omnisharp
    :ensure t
    :after csharp-mode
    :diminish omnisharp
    :config
    (defun my/csharp-mode-hook ()
      (setq indent-tabs-mode nil)
      (setq c-syntactic-indentation t)
      (setq c-basic-offset 4)
      (setq truncate-lines t)
      (setq tab-width 4)
      (setq evil-shift-width 4)
      (c-set-style "ellemtel")
      (local-set-key (kbd "C-x t b") 'omnisharp-unit-test-buffer)
      (local-set-key (kbd "C-x t p") 'omnisharp-unit-test-at-point)
      (flycheck-mode))

    (add-hook 'csharp-mode-hook 'omnisharp-mode)
    ; (add-hook 'csharp-mode-hook 'flycheck-mode)
    (add-hook 'csharp-mode-hook 'my/csharp-mode-hook)
    (eval-after-load
        'company
      '(add-to-list 'company-backends 'company-omnisharp)))

  (use-package dotnet
    :ensure t
    :disabled t
    :config
    (add-hook 'csharp-mode-hook 'dotnet-mode))
#+END_SRC
*** Typscript mode
Setup tools and linters to help with workin in Typescript
#+BEGIN_SRC emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    ;; company is an optional dependency. You have to
    ;; install it separately via package-install
    ;; `M-x package-install [ret] company`
    (company-mode +1))

  (use-package tide
    :ensure t
    :config
    (progn
      ;; aligns annotation to the right hand side
      (setq company-tooltip-align-annotations t)

      ;; formats the buffer before saving
      (add-hook 'before-save-hook 'tide-format-before-save)

      (add-hook 'typescript-mode-hook #'setup-tide-mode)))
#+END_SRC
*** Lua mode
Enable Lua mode for emacs
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :ensure t)
#+END_SRC
*** Go Lang support
Let's see what this whole Go Lang thing is all about and why everyone
is making a huge fuss over it.
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t
    :bind (("C-c C-r" . go-remove-unused-imports)
           ("C-c C-g" . go-goto-imports)
           ("C-c C-f" . gofmt)
           ("C-c C-k" . godoc))
    :config
    (progn
      (setenv "GOPATH" "/Users/jrsteele/Projects/go")
      ;; (setq gofmt-command "/home/inkel/dev/go/bin/goimports")
      (add-hook 'go-mode-hook 'flycheck-mode)
      (add-hook 'before-save-hook 'gofmt-before-save)))

  ;; (use-package go-guru
  ;;   :ensure t
  ;;   :config (progn
  ;;             (setenv "GOPATH" "/Users/jrsteele/Projects/go")))
  ;;             ;; (setq go-guru-command "/home/inkel/dev/go/bin/guru")
  ;;             ;; (add-hook 'go-mode-hook #'go-guru-hl-identifier-mode)))

  ;; (use-package golint
  ;;   :load-path "/home/inkel/dev/go/src/github.com/golang/lint/misc/emacs")

  (use-package company-go
    :ensure t
    :config
    (progn
      (setq company-go-gocode-command "/Users/jrsteele/Projects/go/bin/gocode")
      (defun my/company-go-hook ()
        (set (make-local-variable 'company-backends) '(company-go)))
      (add-hook 'go-mode-hook 'my/company-go-hook)))
#+END_SRC
*** Erlang Mode
Since CouchDB supports Erlang views, it's time I got functional
#+BEGIN_SRC emacs-lisp
  (use-package erlang
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.P\\'" . erlang-mode))
    (add-to-list 'auto-mode-alist '("\\.E\\'" . erlang-mode))
    (add-to-list 'auto-mode-alist '("\\.S\\'" . erlang-mode))
    :config
    (add-hook 'erlang-mode-hook
              (lambda ()
                (setq mode-name "erl"
                      erlang-compile-extra-opts '((i . "../include"))
                      erlang-root-dir "/usr/local/lib/erlang"))))
#+END_SRC
*** PlatformIO
Sure, why not try this out as well. I have a couple of embedded
devices around the house and the Arduino IDE is less than stallar.
#+BEGIN_SRC emacs-lisp
  (use-package platformio-mode
    :ensure t
    :commands (platformio-conditionally-enable)
    :config
    (add-hook 'c++-mode-hook (lambda ()
                               (platformio-conditionally-enable)))
    (add-hook 'c-mode-hook (lambda ()
                             (platformio-conditionally-enable)))
    (add-to-list 'auto-mode-alist '("\\.ino$" . arduino-mode)))

    ;; (projectile-register-project-type 'platformio
    ;;                                   '("platformio.ini")
    ;;                                   "platformio run" nil "platformio run -t upload"))
#+END_SRC
** Greenphire related settings
*** Shorten project directory names
Make the directory names shorter, if at all possible, when working within a
virtual environment.
#+BEGIN_SRC emacs-lisp
  ;; (defun clincard/shorten-dirs ()
  ;;   (add-to-list 'sml/replacer-regexp-list
  ;;                '("^/Volumes/work/clincard/src/greenphire/web/" ":web:") t))
  ;; (if (getenv "S") (clincard/shorten-dirs))
  ;; (setq pyvenv-post-activate-hooks '(clincard/shorten-dirs
  ;;                                    sml/toggle-shorten-directory))
#+END_SRC
*** Clincard Testing
The functions listed below will automatically create a new ~comint~ buffer and
run Clincard's test scripts from within that. Hopefully, once the test suite is
straightened out, I can utilize the test runner that comes with =Pony= rather
than using these custom methods.
**** Django Unit Tests
Run the standard Django unit tests
#+BEGIN_SRC emacs-lisp
  (defun clincard/django-tests
      (test-name)
    (interactive "sEnter Test Name: ")
    (ansi-color-for-comint-mode-on)
    (setenv "EXTRA" "-v2 --failfast")
    (make-comint "Python[Django Tests]"
                 (concat (getenv "S") "/django_tests.sh")
                 nil
                 test-name))
#+END_SRC
**** CC-Mock Tests
Run the ever so lovely CC Mock integration tests with selenium.
#+BEGIN_SRC emacs-lisp
  (defun clincard/ccmock-tests
      (test-name)
    (interactive "sEnter Test Name: ")
    (ansi-color-for-comint-mode-on)
    (setenv "EXTRA" "-v2 --failfast")
    (make-comint "Python[Django Tests]"
                 (concat (getenv "S")
                         "/cc_mock_tests.sh")
                 nil
                 test-name))
#+END_SRC
**** Browser / Legacy Integration Tests
Run our legacy browser tests that utilize fixture data.
#+BEGIN_SRC emacs-lisp
  (defun clincard/browser-tests
      (test-name)
    (interactive "sEnter Test Name: ")
    (ansi-color-for-comint-mode-on)
    (setenv "EXTRA" "-v2 --failfast")
    (make-comint "Python[Django Tests]"
                 (concat (getenv "S")
                         "/end_to_end.sh")
                 nil
                 test-name))
#+END_SRC
*** Clincard Database creation
**** Create a branch database
Create a database with testing data for the current branch.
#+BEGIN_SRC emacs-lisp
  (defun clincard/create-branch-db
      ()
    (interactive)
    (ansi-color-for-comint-mode-on)
    (split-window-sensibly)
    (make-comint "Create Branch DB"
                 (concat (getenv "S")
                         "/create_branch_database.sh"
                         nil))
    (switch-to-buffer "*Create Branch DB*"))
#+END_SRC
**** Load Sanitized Backup
Create a database based off of a template that contains a sanitized copy of our
production data.
#+BEGIN_SRC emacs-lisp
  (defun clincard/load-prod-backup
      ()
    (interactive)
    (ansi-color-for-comint-mode-on)
    (split-window-sensibly)
    (make-comint "Load Production Backup"
                 (concat (getenv "S")
                         "/load_prod_backup.sh")
                 nil
                 "-c"))
#+END_SRC
*** Remote hosts
Access remote hosts directly through emacs
**** My local test instance, aka, clincard-test
#+BEGIN_SRC emacs-lisp
  (defun open-clincard-test()
    (interactive)
    (remote-term "clincard-test" "ssh" "-L 5900:localhost:5900" "clincard-test"))
#+END_SRC
*** Run ClinCard Microservices in Development mode
The function listed below will execute the specified service
defined in variable =service-name= for execution within a python
inferior shell to allow debugging a la =pdb=.
#+BEGIN_SRC emacs-lisp
  (defvar service-name
    nil
    "The executable name of the microservice to call.")

  (defun run-service (config-file)
    "Run the application"
    (interactive "fConfig file: ")
    (let ((python-shell-interpreter-args
           (concat (executable-find service-name)
                   " -- -d -c "
                   config-file)))
      (python-shell-make-comint (python-shell-parse-command) "service")))
#+END_SRC
** Reset to sane defaults after loading
Set the garbage collection threshold back to a sane level
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'emacs-startup-hook
  ;;           (lambda () (setq gc-cons-threshold 16777216
  ;;                 gc-cons-percentage 0.1)))
#+END_SRC

Also re-add the file-name-handler list

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'emacs-startup-hook
  ;;           (lambda () (setq file-name-handler-alist temp--file-name-handler-alist)))
#+END_SRC
